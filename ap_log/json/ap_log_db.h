////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by slothjson. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#ifndef __ap_log_db_20180703170722_h__
#define __ap_log_db_20180703170722_h__

#include "slothjson.h"

namespace slothjson {

struct cs_name_t
{
    std::string Name;

    void skip_Name() { __skip_Name = true; }

    bool json_has_Name() const { return __json_has_Name; }

    cs_name_t();
    cs_name_t& operator=(const cs_name_t& obj_val);
    bool operator==(const cs_name_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_Name;

    bool __json_has_Name;
};

bool encode(const cs_name_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, cs_name_t& obj_val);

struct index_create_t
{
    std::string indexDef;
    std::string pIndexName;
    int32_t isUnique;
    int32_t isEnforced;

    void skip_indexDef() { __skip_indexDef = true; }
    void skip_pIndexName() { __skip_pIndexName = true; }
    void skip_isUnique() { __skip_isUnique = true; }
    void skip_isEnforced() { __skip_isEnforced = true; }

    bool json_has_indexDef() const { return __json_has_indexDef; }
    bool json_has_pIndexName() const { return __json_has_pIndexName; }
    bool json_has_isUnique() const { return __json_has_isUnique; }
    bool json_has_isEnforced() const { return __json_has_isEnforced; }

    index_create_t();
    index_create_t& operator=(const index_create_t& obj_val);
    bool operator==(const index_create_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_indexDef;
    bool __skip_pIndexName;
    bool __skip_isUnique;
    bool __skip_isEnforced;

    bool __json_has_indexDef;
    bool __json_has_pIndexName;
    bool __json_has_isUnique;
    bool __json_has_isEnforced;
};

bool encode(const index_create_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, index_create_t& obj_val);

struct index_param_time_t
{
    std::string index_name;
    int32_t param_time;

    void skip_index_name() { __skip_index_name = true; }
    void skip_param_time() { __skip_param_time = true; }

    bool json_has_index_name() const { return __json_has_index_name; }
    bool json_has_param_time() const { return __json_has_param_time; }

    index_param_time_t();
    index_param_time_t& operator=(const index_param_time_t& obj_val);
    bool operator==(const index_param_time_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_index_name;
    bool __skip_param_time;

    bool __json_has_index_name;
    bool __json_has_param_time;
};

bool encode(const index_param_time_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, index_param_time_t& obj_val);

struct index_mac_t
{
    std::string index_name;
    int32_t mac;

    void skip_index_name() { __skip_index_name = true; }
    void skip_mac() { __skip_mac = true; }

    bool json_has_index_name() const { return __json_has_index_name; }
    bool json_has_mac() const { return __json_has_mac; }

    index_mac_t();
    index_mac_t& operator=(const index_mac_t& obj_val);
    bool operator==(const index_mac_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_index_name;
    bool __skip_mac;

    bool __json_has_index_name;
    bool __json_has_mac;
};

bool encode(const index_mac_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, index_mac_t& obj_val);

struct index_ID_t
{
    std::string index_name;
    int32_t ID;

    void skip_index_name() { __skip_index_name = true; }
    void skip_ID() { __skip_ID = true; }

    bool json_has_index_name() const { return __json_has_index_name; }
    bool json_has_ID() const { return __json_has_ID; }

    index_ID_t();
    index_ID_t& operator=(const index_ID_t& obj_val);
    bool operator==(const index_ID_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_index_name;
    bool __skip_ID;

    bool __json_has_index_name;
    bool __json_has_ID;
};

bool encode(const index_ID_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, index_ID_t& obj_val);

struct index_addtime_t
{
    std::string index_name;
    int32_t addtime;

    void skip_index_name() { __skip_index_name = true; }
    void skip_addtime() { __skip_addtime = true; }

    bool json_has_index_name() const { return __json_has_index_name; }
    bool json_has_addtime() const { return __json_has_addtime; }

    index_addtime_t();
    index_addtime_t& operator=(const index_addtime_t& obj_val);
    bool operator==(const index_addtime_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_index_name;
    bool __skip_addtime;

    bool __json_has_index_name;
    bool __json_has_addtime;
};

bool encode(const index_addtime_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, index_addtime_t& obj_val);

struct index_mac_RPCMethod_t
{
    std::string index_name;
    int32_t mac;
    int32_t RPCMethod;

    void skip_index_name() { __skip_index_name = true; }
    void skip_mac() { __skip_mac = true; }
    void skip_RPCMethod() { __skip_RPCMethod = true; }

    bool json_has_index_name() const { return __json_has_index_name; }
    bool json_has_mac() const { return __json_has_mac; }
    bool json_has_RPCMethod() const { return __json_has_RPCMethod; }

    index_mac_RPCMethod_t();
    index_mac_RPCMethod_t& operator=(const index_mac_RPCMethod_t& obj_val);
    bool operator==(const index_mac_RPCMethod_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_index_name;
    bool __skip_mac;
    bool __skip_RPCMethod;

    bool __json_has_index_name;
    bool __json_has_mac;
    bool __json_has_RPCMethod;
};

bool encode(const index_mac_RPCMethod_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, index_mac_RPCMethod_t& obj_val);

struct ap_log_config_t
{
    std::string param_name;
    uint64_t param_time;
    uint64_t param_value;

    void skip_param_name() { __skip_param_name = true; }
    void skip_param_time() { __skip_param_time = true; }
    void skip_param_value() { __skip_param_value = true; }

    bool json_has_param_name() const { return __json_has_param_name; }
    bool json_has_param_time() const { return __json_has_param_time; }
    bool json_has_param_value() const { return __json_has_param_value; }

    ap_log_config_t();
    ap_log_config_t& operator=(const ap_log_config_t& obj_val);
    bool operator==(const ap_log_config_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_param_name;
    bool __skip_param_time;
    bool __skip_param_value;

    bool __json_has_param_name;
    bool __json_has_param_time;
    bool __json_has_param_value;
};

bool encode(const ap_log_config_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, ap_log_config_t& obj_val);

struct ap_log_qos_vip_t
{
    std::string mac;
    uint64_t addtime;
    std::string info;
    int32_t loglev;

    void skip_mac() { __skip_mac = true; }
    void skip_addtime() { __skip_addtime = true; }
    void skip_info() { __skip_info = true; }
    void skip_loglev() { __skip_loglev = true; }

    bool json_has_mac() const { return __json_has_mac; }
    bool json_has_addtime() const { return __json_has_addtime; }
    bool json_has_info() const { return __json_has_info; }
    bool json_has_loglev() const { return __json_has_loglev; }

    ap_log_qos_vip_t();
    ap_log_qos_vip_t& operator=(const ap_log_qos_vip_t& obj_val);
    bool operator==(const ap_log_qos_vip_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_mac;
    bool __skip_addtime;
    bool __skip_info;
    bool __skip_loglev;

    bool __json_has_mac;
    bool __json_has_addtime;
    bool __json_has_info;
    bool __json_has_loglev;
};

bool encode(const ap_log_qos_vip_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, ap_log_qos_vip_t& obj_val);

struct ap_log_dev_t
{
    std::string RPCMethod;
    std::string ID;
    std::string mac;
    std::string server;
    std::string remote;
    std::string start_time;
    std::string end_time;
    std::string client_ip;
    int32_t direction;
    int32_t Result;
    uint64_t addtime;
    std::string in;
    std::string out;

    void skip_RPCMethod() { __skip_RPCMethod = true; }
    void skip_ID() { __skip_ID = true; }
    void skip_mac() { __skip_mac = true; }
    void skip_server() { __skip_server = true; }
    void skip_remote() { __skip_remote = true; }
    void skip_start_time() { __skip_start_time = true; }
    void skip_end_time() { __skip_end_time = true; }
    void skip_client_ip() { __skip_client_ip = true; }
    void skip_direction() { __skip_direction = true; }
    void skip_Result() { __skip_Result = true; }
    void skip_addtime() { __skip_addtime = true; }
    void skip_in() { __skip_in = true; }
    void skip_out() { __skip_out = true; }

    bool json_has_RPCMethod() const { return __json_has_RPCMethod; }
    bool json_has_ID() const { return __json_has_ID; }
    bool json_has_mac() const { return __json_has_mac; }
    bool json_has_server() const { return __json_has_server; }
    bool json_has_remote() const { return __json_has_remote; }
    bool json_has_start_time() const { return __json_has_start_time; }
    bool json_has_end_time() const { return __json_has_end_time; }
    bool json_has_client_ip() const { return __json_has_client_ip; }
    bool json_has_direction() const { return __json_has_direction; }
    bool json_has_Result() const { return __json_has_Result; }
    bool json_has_addtime() const { return __json_has_addtime; }
    bool json_has_in() const { return __json_has_in; }
    bool json_has_out() const { return __json_has_out; }

    ap_log_dev_t();
    ap_log_dev_t& operator=(const ap_log_dev_t& obj_val);
    bool operator==(const ap_log_dev_t& obj_val) const;
    bool encode(allocator_t& alloc, rapidjson::Value& json_val) const;
    bool decode(const rapidjson::Value& json_val);

private:
    bool __skip_RPCMethod;
    bool __skip_ID;
    bool __skip_mac;
    bool __skip_server;
    bool __skip_remote;
    bool __skip_start_time;
    bool __skip_end_time;
    bool __skip_client_ip;
    bool __skip_direction;
    bool __skip_Result;
    bool __skip_addtime;
    bool __skip_in;
    bool __skip_out;

    bool __json_has_RPCMethod;
    bool __json_has_ID;
    bool __json_has_mac;
    bool __json_has_server;
    bool __json_has_remote;
    bool __json_has_start_time;
    bool __json_has_end_time;
    bool __json_has_client_ip;
    bool __json_has_direction;
    bool __json_has_Result;
    bool __json_has_addtime;
    bool __json_has_in;
    bool __json_has_out;
};

bool encode(const ap_log_dev_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val);
bool decode(const rapidjson::Value& json_val, ap_log_dev_t& obj_val);

} // namespace slothjson

#endif // __ap_log_db_20180703170722_h__